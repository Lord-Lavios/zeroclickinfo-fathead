applyMiddleware	A									https://raw.githubusercontent.com/reactjs/redux/master/logo/logo.png	<section class="prog__container"><pre><code>applyMiddleware(...middlewares)</code></pre><p>Middleware is the suggested way to extend Redux with custom functionality. Middleware lets you wrap the store&apos;s <code>dispatch</code> method for fun and profit. The key feature of middleware is that it is composable. Multiple middleware can be combined together, where each middleware requires no knowledge of what comes before or after it in the chain.</p><p>The most common use case for middleware is to support asynchronous actions without much boilerplate code or a dependency on a library like Rx. It does so by letting you dispatch async actions in addition to normal actions.</p><p>For example, redux-thunk lets the action creators invert control by dispatching functions. They would receive <code>dispatch</code> as an argument and may call it asynchronously. Such functions are called <em>thunks</em>. Another example of middleware is redux-promise. It lets you dispatch a Promise async action, and dispatches a normal action when the Promise resolves.</p><p>Middleware is not baked into <code>createStore</code> and is not a fundamental part of the Redux architecture, but we consider it useful enough to be supported right in the core. This way, there is a single standard way to extend <code>dispatch</code> in the ecosystem, and different middleware may compete in expressiveness and utility.</p><span class="prog__sub">Arguments</span><span class="prog__ul"><li><code>...middlewares</code> (<em>arguments</em>): Functions that conform to the Redux <em>middleware API</em>. Each middleware receives <code>Store</code>&apos;s <code>dispatch</code> and <code>getState</code> functions as named arguments, and returns a function. That function will be given the <code>next</code> middleware&apos;s dispatch method, and is expected to return a function of <code>action</code> calling <code>next(action)</code> with a potentially different argument, or at a different time, or maybe not calling it at all. The last middleware in the chain will receive the real store&apos;s <code>dispatch</code> method as the <code>next</code> parameter, thus ending the chain. So, the middleware signature is <code>({ getState, dispatch }) =&gt; next =&gt; action</code>.</li></span><span class="prog__sub">Returns</span><p>(<em>Function</em>) A store enhancer that applies the given middleware. The store enhancer signature is <code>createStore =&gt; createStore&apos;</code> but the easiest way to apply it is to pass it to <code>createStore()</code> as the last <code>enhancer</code> argument.</p><span class="prog__sub">Example: Custom Logger Middleware</span><pre><pre><code>import { createStore, applyMiddleware } from 'redux'\nimport todos from './reducers'\n\nfunction logger({ getState }) {\n  return (next) => (action) => {\n    console.log('will dispatch', action)\n\n    // Call the next dispatch method in the middleware chain.\n    let returnValue = next(action)\n\n    console.log('state after dispatch', getState())\n\n    // This will likely be the action itself, unless\n    // a middleware further in chain changed it.\n    return returnValue\n  }\n}\n\nlet store = createStore(\n  todos,\n  [ 'Use Redux' ],\n  applyMiddleware(logger)\n)\n\nstore.dispatch({\n  type: 'ADD_TODO',\n  text: 'Understand the middleware'\n})\n// (These lines will be logged by the middleware:)\n// will dispatch: { type: 'ADD_TODO', text: 'Understand the middleware' }\n// state after dispatch: [ 'Use Redux', 'Understand the middleware' ]\n</code></pre></pre><span class="prog__sub">Example: Using Thunk Middleware for Async Actions</span><pre><pre><code>import { createStore, combineReducers, applyMiddleware } from 'redux'\nimport thunk from 'redux-thunk'\nimport * as reducers from './reducers'\n\nlet reducer = combineReducers(reducers)\n// applyMiddleware supercharges createStore with middleware:\nlet store = createStore(reducer, applyMiddleware(thunk))\n\nfunction fetchSecretSauce() {\n  return fetch('https://www.google.com/search?q=secret+sauce')\n}\n\n// These are the normal action creators you have seen so far.\n// The actions they return can be dispatched without any middleware.\n// However, they only express “facts” and not the “async flow”.\n\nfunction makeASandwich(forPerson, secretSauce) {\n  return {\n    type: 'MAKE_SANDWICH',\n    forPerson,\n    secretSauce\n  }\n}\n\nfunction apologize(fromPerson, toPerson, error) {\n  return {\n    type: 'APOLOGIZE',\n    fromPerson,\n    toPerson,\n    error\n  }\n}\n\nfunction withdrawMoney(amount) {\n  return {\n    type: 'WITHDRAW',\n    amount\n  }\n}\n\n// Even without middleware, you can dispatch an action:\nstore.dispatch(withdrawMoney(100))\n\n// But what do you do when you need to start an asynchronous action,\n// such as an API call, or a router transition?\n\n// Meet thunks.\n// A thunk is a function that returns a function.\n// This is a thunk.\n\nfunction makeASandwichWithSecretSauce(forPerson) {\n\n  // Invert control!\n  // Return a function that accepts `dispatch` so we can dispatch later.\n  // Thunk middleware knows how to turn thunk async actions into actions.\n\n  return function (dispatch) {\n    return fetchSecretSauce().then(\n      sauce => dispatch(makeASandwich(forPerson, sauce)),\n      error => dispatch(apologize('The Sandwich Shop', forPerson, error))\n    )\n  }\n}\n\n// Thunk middleware lets me dispatch thunk async actions\n// as if they were actions!\n\nstore.dispatch(\n  makeASandwichWithSecretSauce('Me')\n)\n\n// It even takes care to return the thunk's return value\n// from the dispatch, so I can chain Promises as long as I return them.\n\nstore.dispatch(\n  makeASandwichWithSecretSauce('My wife')\n).then(() => {\n  console.log('Done!')\n})\n\n// In fact I can write action creators that dispatch\n// actions and async actions from other action creators,\n// and I can build my control flow with Promises.\n\nfunction makeSandwichesForEverybody() {\n  return function (dispatch, getState) {\n    if (!getState().sandwiches.isShopOpen) {\n\n      // You don't have to return Promises, but it's a handy convention\n      // so the caller can always call .then() on async dispatch result.\n\n      return Promise.resolve()\n    }\n\n    // We can dispatch both plain object actions and other thunks,\n    // which lets us compose the asynchronous actions in a single flow.\n\n    return dispatch(\n      makeASandwichWithSecretSauce('My Grandma')\n    ).then(() =>\n      Promise.all([\n        dispatch(makeASandwichWithSecretSauce('Me')),\n        dispatch(makeASandwichWithSecretSauce('My wife'))\n      ])\n    ).then(() =>\n      dispatch(makeASandwichWithSecretSauce('Our kids'))\n    ).then(() =>\n      dispatch(getState().myMoney > 42 ?\n        withdrawMoney(42) :\n        apologize('Me', 'The Sandwich Shop')\n      )\n    )\n  }\n}\n\n// This is very useful for server side rendering, because I can wait\n// until data is available, then synchronously render the app.\n\nimport { renderToString } from 'react-dom/server'\n\nstore.dispatch(\n  makeSandwichesForEverybody()\n).then(() =>\n  response.send(renderToString(<MyApp store={store} />))\n)\n\n// I can also dispatch a thunk async action from a component\n// any time its props change to load the missing data.\n\nimport { connect } from 'react-redux'\nimport { Component } from 'react'\n\nclass SandwichShop extends Component {\n  componentDidMount() {\n    this.props.dispatch(\n      makeASandwichWithSecretSauce(this.props.forPerson)\n    )\n  }\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.forPerson !== this.props.forPerson) {\n      this.props.dispatch(\n        makeASandwichWithSecretSauce(nextProps.forPerson)\n      )\n    }\n  }\n\n  render() {\n    return <p>{this.props.sandwiches.join('mustard')}</p>\n  }\n}\n\nexport default connect(\n  state => ({\n    sandwiches: state.sandwiches\n  })\n)(SandwichShop)\n</code></pre></pre><span class="prog__sub">Tips</span><span class="prog__ul"><li><p>Middleware only wraps the store&apos;s <code>dispatch</code> function. Technically, anything a middleware can do, you can do manually by wrapping every <code>dispatch</code> call, but it&apos;s easier to manage this in a single place and define action transformations on the scale of the whole project.</p>\n</li><li><p>If you use other store enhancers in addition to <code>applyMiddleware</code>, make sure to put <code>applyMiddleware</code> before them in the composition chain because the middleware is potentially asynchronous. For example, it should go before redux-devtools because otherwise the DevTools won&apos;t see the raw actions emitted by the Promise middleware and such.</p>\n</li><li><p>If you want to conditionally apply a middleware, make sure to only import it when it&apos;s needed:</p><pre><code>let middleware = [ a, b ]\nif (process.env.NODE_ENV !== 'production') {\n  let c = require('some-debug-middleware')\n  let d = require('another-debug-middleware')\n  middleware = [ ...middleware, c, d ]\n}\n\nconst store = createStore(\n  reducer,\n  preloadedState,\n  applyMiddleware(...middleware)\n)\n</code></pre><p>This makes it easier for bundling tools to cut out unneeded modules and reduces the size of your builds.</p></li><li><p>Ever wondered what <code>applyMiddleware</code> itself is? It ought to be an extension mechanism more powerful than the middleware itself. Indeed, <code>applyMiddleware</code> is an example of the most powerful Redux extension mechanism called store enhancers. It is highly unlikely you&apos;ll ever want to write a store enhancer yourself. Another example of a store enhancer is redux-devtools. Middleware is less powerful than a store enhancer, but it is easier to write.</p>\n</li><li><p>Middleware sounds much more complicated than it really is. The only way to really understand middleware is to see how the existing middleware works, and try to write your own. The function nesting can be intimidating, but most of the middleware you&apos;ll find are, in fact, 10-liners, and the nesting and composability is what makes the middleware system powerful.</p>\n</li><li><p>To apply multiple store enhancers, you may use <code>compose()</code>.</p>\n</li></span></section>	http://redux.js.org/docs/api/applyMiddleware.htmlundefined
bindActionCreators	A									https://raw.githubusercontent.com/reactjs/redux/master/logo/logo.png	<section class="prog__container"><pre><code>bindActionCreators(actionCreators, dispatch)</code></pre><p>Turns an object whose values are action creators, into an object with the same keys, but with every action creator wrapped into a <code>dispatch</code> call so they may be invoked directly.</p><p>Normally you should just call <code>dispatch</code> directly on your <code>Store</code> instance. If you use Redux with React, react-redux will provide you with the <code>dispatch</code> function so you can call it directly, too.</p><p>The only use case for <code>bindActionCreators</code> is when you want to pass some action creators down to a component that isn&apos;t aware of Redux, and you don&apos;t want to pass <code>dispatch</code> or the Redux store to it.</p><p>For convenience, you can also pass a single function as the first argument, and get a function in return.</p><span class="prog__sub">Parameters</span><ol><li><p><code>actionCreators</code> (<em>Function</em> or <em>Object</em>): An action creator, or an object whose values are action creators.</p>\n</li><li><p><code>dispatch</code> (<em>Function</em>): A <code>dispatch</code> function available on the <code>Store</code> instance.</p>\n</li></ol><span class="prog__sub">Returns</span><p>(<em>Function</em> or <em>Object</em>): An object mimicking the original object, but with each function immediately dispatching the action returned by the corresponding action creator. If you passed a function as <code>actionCreators</code>, the return value will also be a single function.</p><span class="prog__sub">Example</span><span class="prog__sub"><code>TodoActionCreators.js</code></span><pre><pre><code>export function addTodo(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n\nexport function removeTodo(id) {\n  return {\n    type: 'REMOVE_TODO',\n    id\n  }\n}\n</code></pre></pre><span class="prog__sub"><code>SomeComponent.js</code></span><pre><pre><code>import { Component } from 'react'\nimport { bindActionCreators } from 'redux'\nimport { connect } from 'react-redux'\n\nimport * as TodoActionCreators from './TodoActionCreators'\nconsole.log(TodoActionCreators)\n// {\n//   addTodo: Function,\n//   removeTodo: Function\n// }\n\nclass TodoListContainer extends Component {\n  componentDidMount() {\n    // Injected by react-redux:\n    let { dispatch } = this.props\n\n    // Note: this won't work:\n    // TodoActionCreators.addTodo('Use Redux')\n\n    // You're just calling a function that creates an action.\n    // You must dispatch the action, too!\n\n    // This will work:\n    let action = TodoActionCreators.addTodo('Use Redux')\n    dispatch(action)\n  }\n\n  render() {\n    // Injected by react-redux:\n    let { todos, dispatch } = this.props\n\n    // Here's a good use case for bindActionCreators:\n    // You want a child component to be completely unaware of Redux.\n\n    let boundActionCreators = bindActionCreators(TodoActionCreators, dispatch)\n    console.log(boundActionCreators)\n    // {\n    //   addTodo: Function,\n    //   removeTodo: Function\n    // }\n\n    return (\n      <TodoList todos={todos}\n                {...boundActionCreators} />\n    )\n\n    // An alternative to bindActionCreators is to pass\n    // just the dispatch function down, but then your child component\n    // needs to import action creators and know about them.\n\n    // return <TodoList todos={todos} dispatch={dispatch} />\n  }\n}\n\nexport default connect(\n  state => ({ todos: state.todos })\n)(TodoListContainer)\n</code></pre></pre><span class="prog__sub">Tips</span><span class="prog__ul"><li><p>You might ask: why don&apos;t we bind the action creators to the store instance right away, like in classical Flux? The problem is that this won&apos;t work well with universal apps that need to render on the server. Most likely you want to have a separate store instance per request so you can prepare them with different data, but binding action creators during their definition means you&apos;re stuck with a single store instance for all requests.</p>\n</li><li><p>If you use ES5, instead of <code>import * as</code> syntax you can just pass <code>require(&apos;./TodoActionCreators&apos;)</code> to <code>bindActionCreators</code> as the first argument. The only thing it cares about is that the values of the <code>actionCreators</code> arguments are functions. The module system doesn&apos;t matter.</p>\n</li></span></section>	http://redux.js.org/docs/api/bindActionCreators.htmlundefined
combineReducers	A									https://raw.githubusercontent.com/reactjs/redux/master/logo/logo.png	<section class="prog__container"><pre><code>combineReducers(reducers)</code></pre><p>As your app grows more complex, you&apos;ll want to split your reducing function into separate functions, each managing independent parts of the state.</p><p>The <code>combineReducers</code> helper function turns an object whose values are different reducing functions into a single reducing function you can pass to <code>createStore</code>.</p><p>The resulting reducer calls every child reducer, and gathers their results into a single state object. <strong>The shape of the state object matches the keys of the passed <code>reducers</code></strong>.</p><p>Consequently, the state object will look like this: </p><pre><pre><code>{\n  reducer1: ...\n  reducer2: ...\n}\n</code></pre></pre><p>You can control state key names by using different keys for the reducers in the passed object. For example, you may call <code>combineReducers({ todos: myTodosReducer, counter: myCounterReducer })</code> for the state shape to be <code>{ todos, counter }</code>.</p><p>A popular convention is to name reducers after the state slices they manage, so you can use ES6 property shorthand notation: <code>combineReducers({ counter, todos })</code>. This is equivalent to writing <code>combineReducers({ counter: counter, todos: todos })</code>.</p><blockquote></blockquote><span class="prog__sub">Arguments</span><ol><li><code>reducers</code> (<em>Object</em>): An object whose values correspond to different reducing functions that need to be combined into one. See the notes below for some rules every passed reducer must follow.</li></ol><blockquote></blockquote><span class="prog__sub">Returns</span><p>(<em>Function</em>): A reducer that invokes every reducer inside the <code>reducers</code> object, and constructs a state object with the same shape.</p><span class="prog__sub">Notes</span><p>This function is mildly opinionated and is skewed towards helping beginners avoid common pitfalls. This is why it attempts to enforce some rules that you don&apos;t have to follow if you write the root reducer manually.</p><p>Any reducer passed to <code>combineReducers</code> must satisfy these rules:</p><span class="prog__ul"><li><p>For any action that is not recognized, it must return the <code>state</code> given to it as the first argument.</p>\n</li><li><p>It must never return <code>undefined</code>. It is too easy to do this by mistake via an early <code>return</code> statement, so <code>combineReducers</code> throws if you do that instead of letting the error manifest itself somewhere else.</p>\n</li><li><p>If the <code>state</code> given to it is <code>undefined</code>, it must return the initial state for this specific reducer. According to the previous rule, the initial state must not be <code>undefined</code> either. It is handy to specify it with ES6 optional arguments syntax, but you can also explicitly check the first argument for being <code>undefined</code>.</p>\n</li></span><p>While <code>combineReducers</code> attempts to check that your reducers conform to some of these rules, you should remember them, and do your best to follow them. <code>combineReducers</code> will check your reducers by passing <code>undefined</code> to them; this is done even if you specify initial state to <code>Redux.createStore(combineReducers(...), initialState)</code>. Therefore, you <strong>must</strong> ensure your reducers work properly when receiving <code>undefined</code> as state, even if you never intend for them to actually receive <code>undefined</code> in your own code.</p><span class="prog__sub">Example</span><span class="prog__sub"><code>reducers/todos.js</code></span><pre><pre><code>export default function todos(state = [], action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return state.concat([ action.text ])\n    default:\n      return state\n  }\n}\n</code></pre></pre><span class="prog__sub"><code>reducers/counter.js</code></span><pre><pre><code>export default function counter(state = 0, action) {\n  switch (action.type) {\n    case 'INCREMENT':\n      return state + 1\n    case 'DECREMENT':\n      return state - 1\n    default:\n      return state\n  }\n}\n</code></pre></pre><span class="prog__sub"><code>reducers/index.js</code></span><pre><pre><code>import { combineReducers } from 'redux'\nimport todos from './todos'\nimport counter from './counter'\n\nexport default combineReducers({\n  todos,\n  counter\n})\n</code></pre></pre><span class="prog__sub"><code>App.js</code></span><pre><pre><code>import { createStore } from 'redux'\nimport reducer from './reducers/index'\n\nlet store = createStore(reducer)\nconsole.log(store.getState())\n// {\n//   counter: 0,\n//   todos: []\n// }\n\nstore.dispatch({\n  type: 'ADD_TODO',\n  text: 'Use Redux'\n})\nconsole.log(store.getState())\n// {\n//   counter: 0,\n//   todos: [ 'Use Redux' ]\n// }\n</code></pre></pre><span class="prog__sub">Tips</span><span class="prog__ul"><li><p>This helper is just a convenience! You can write your own <code>combineReducers</code> that works differently, or even assemble the state object from the child reducers manually and write a root reducing function explicitly, like you would write any other function.</p>\n</li><li><p>You may call <code>combineReducers</code> at any level of the reducer hierarchy. It doesn&apos;t have to happen at the top. In fact you may use it again to split the child reducers that get too complicated into independent grandchildren, and so on.</p>\n</li></span></section>	http://redux.js.org/docs/api/combineReducers.htmlundefined
compose	A									https://raw.githubusercontent.com/reactjs/redux/master/logo/logo.png	<section class="prog__container"><pre><code>compose(...functions)</code></pre><p>Composes functions from right to left.</p><p>This is a functional programming utility, and is included in Redux as a convenience.<br>You might want to use it to apply several store enhancers in a row.</p><span class="prog__sub">Arguments</span><ol><li>(<em>arguments</em>): The functions to compose. Each function is expected to accept a single parameter. Its return value will be provided as an argument to the function standing to the left, and so on. The exception is the right-most argument which can accept multiple parameters, as it will provide the signature for the resulting composed function.</li></ol><span class="prog__sub">Returns</span><p>(<em>Function</em>): The final function obtained by composing the given functions from right to left.</p><span class="prog__sub">Example</span><p>This example demonstrates how to use <code>compose</code> to enhance a store with <code>applyMiddleware</code> and a few developer tools from the redux-devtools package.</p><pre><pre><code>import { createStore, combineReducers, applyMiddleware, compose } from 'redux'\nimport thunk from 'redux-thunk'\nimport DevTools from './containers/DevTools'\nimport reducer from '../reducers/index'\n\nconst store = createStore(\n  reducer,\n  compose(\n    applyMiddleware(thunk),\n    DevTools.instrument()\n  )\n)\n</code></pre></pre><span class="prog__sub">Tips</span><span class="prog__ul"><li>All <code>compose</code> does is let you write deeply nested function transformations without the rightward drift of the code. Don&apos;t give it too much credit!</li></span></section>	http://redux.js.org/docs/api/compose.htmlundefined
createStore	A									https://raw.githubusercontent.com/reactjs/redux/master/logo/logo.png	<section class="prog__container"><pre><code>createStore(reducer, [preloadedState], [enhancer])</code></pre><p>Creates a Redux store that holds the complete state tree of your app.<br>There should only be a single store in your app.</p><span class="prog__sub">Arguments</span><ol><li><p><code>reducer</code> <em>(Function)</em>: A reducing function that returns the next state tree, given the current state tree and an action to handle.</p>\n</li><li><p>[<code>preloadedState</code>] <em>(any)</em>: The initial state. You may optionally specify it to hydrate the state from the server in universal apps, or to restore a previously serialized user session. If you produced <code>reducer</code> with <code>combineReducers</code>, this must be a plain object with the same shape as the keys passed to it. Otherwise, you are free to pass anything that your <code>reducer</code> can understand.</p>\n</li><li><p>[<code>enhancer</code>] <em>(Function)</em>: The store enhancer. You may optionally specify it to enhance the store with third-party capabilities such as middleware, time travel, persistence, etc. The only store enhancer that ships with Redux is <code>applyMiddleware()</code>.</p>\n</li></ol><span class="prog__sub">Returns</span><p>(<em><code>Store</code></em>): An object that holds the complete state of your app. The only way to change its state is by dispatching actions. You may also subscribe to the changes to its state to update the UI.</p><span class="prog__sub">Example</span><pre><pre><code>import { createStore } from 'redux'\n\nfunction todos(state = [], action) {\n  switch (action.type) {\n    case 'ADD_TODO':\n      return state.concat([ action.text ])\n    default:\n      return state\n  }\n}\n\nlet store = createStore(todos, [ 'Use Redux' ])\n\nstore.dispatch({\n  type: 'ADD_TODO',\n  text: 'Read the docs'\n})\n\nconsole.log(store.getState())\n// [ 'Use Redux', 'Read the docs' ]\n</code></pre></pre><span class="prog__sub">Tips</span><span class="prog__ul"><li><p>Don&apos;t create more than one store in an application! Instead, use <code>combineReducers</code> to create a single root reducer out of many.</p>\n</li><li><p>It is up to you to choose the state format. You can use plain objects or something like Immutable. If you&apos;re not sure, start with plain objects.</p>\n</li><li><p>If your state is a plain object, make sure you never mutate it! For example, instead of returning something like <code>Object.assign(state, newData)</code> from your reducers, return <code>Object.assign({}, state, newData)</code>. This way you don&apos;t override the previous <code>state</code>. You can also write <code>return { ...state, ...newData }</code> if you enable the object spread operator proposal.</p>\n</li><li><p>For universal apps that run on the server, create a store instance with every request so that they are isolated. Dispatch a few data fetching actions to a store instance and wait for them to complete before rendering the app on the server.</p>\n</li><li><p>When a store is created, Redux dispatches a dummy action to your reducer to populate the store with the initial state. You are not meant to handle the dummy action directly. Just remember that your reducer should return some kind of initial state if the state given to it as the first argument is <code>undefined</code>, and you&apos;re all set.</p>\n</li><li><p>To apply multiple store enhancers, you may use <code>compose()</code>.</p>\n</li></span></section>	http://redux.js.org/docs/api/createStore.htmlundefined
getState	A			Redux Store Functions						https://raw.githubusercontent.com/reactjs/redux/master/logo/logo.png	<section class="prog__container"><pre><code>getState()</code></pre><h3><code>getState()</code></h3><p>Returns the current state tree of your application.<br>It is equal to the last value returned by the store&apos;s reducer.</p><span class="prog__sub">Returns</span><p><em>(any)</em>: The current state tree of your application.</p><h3><code>dispatch(action)</code></h3></section>	http://redux.js.org/docs/api/Store.htmlundefined
dispatch	A			Redux Store Functions						https://raw.githubusercontent.com/reactjs/redux/master/logo/logo.png	<section class="prog__container"><pre><code>dispatch(action)</code></pre><h3><code>dispatch(action)</code></h3><p>Dispatches an action. This is the only way to trigger a state change.</p><p>The store&apos;s reducing function will be called with the current <code>getState()</code> result and the given <code>action</code> synchronously. Its return value will be considered the next state. It will be returned from <code>getState()</code> from now on, and the change listeners will immediately be notified.</p><blockquote></blockquote><span class="prog__sub">Arguments</span><ol><li><code>action</code> (<em>Object</em><sup>&#x2020;</sup>): A plain object describing the change that makes sense for your application. Actions are the only way to get data into the store, so any data, whether from the UI events, network callbacks, or other sources such as WebSockets needs to eventually be dispatched as actions. Actions must have a <code>type</code> field that indicates the type of action being performed. Types can be defined as constants and imported from another module. It&apos;s better to use strings for <code>type</code> than Symbols because strings are serializable. Other than <code>type</code>, the structure of an action object is really up to you. If you&apos;re interested, check out Flux Standard Action for recommendations on how actions could be constructed.</li></ol><span class="prog__sub">Returns</span><p>(Object<sup>&#x2020;</sup>): The dispatched action (see notes).</p><span class="prog__sub">Notes</span><p><sup>&#x2020;</sup> The &#x201C;vanilla&#x201D; store implementation you get by calling <code>createStore</code> only supports plain object actions and hands them immediately to the reducer.</p><p>However, if you wrap <code>createStore</code> with <code>applyMiddleware</code>, the middleware can interpret actions differently, and provide support for dispatching async actions. Async actions are usually asynchronous primitives like Promises, Observables, or thunks.</p><p>Middleware is created by the community and does not ship with Redux by default. You need to explicitly install packages like redux-thunk or redux-promise to use it. You may also create your own middleware.</p><p>To learn how to describe asynchronous API calls, read the current state inside action creators, perform side effects, or chain them to execute in a sequence, see the examples for <code>applyMiddleware</code>.</p><span class="prog__sub">Example</span><pre><pre><code>import { createStore } from 'redux'\nlet store = createStore(todos, [ 'Use Redux' ])\n\nfunction addTodo(text) {\n  return {\n    type: 'ADD_TODO',\n    text\n  }\n}\n\nstore.dispatch(addTodo('Read the docs'))\nstore.dispatch(addTodo('Read about the middleware'))\n</code></pre></pre><h3><code>subscribe(listener)</code></h3></section>	http://redux.js.org/docs/api/Store.htmlundefined
subscribe	A			Redux Store Functions						https://raw.githubusercontent.com/reactjs/redux/master/logo/logo.png	<section class="prog__container"><pre><code>subscribe(listener)</code></pre><h3><code>subscribe(listener)</code></h3><p>Adds a change listener. It will be called any time an action is dispatched, and some part of the state tree may potentially have changed. You may then call <code>getState()</code> to read the current state tree inside the callback.</p><p>You may call <code>dispatch()</code> from a change listener, with the following caveats:</p><ol><li><p>The listener should only call <code>dispatch()</code> either in response to user actions or under specific conditions (e. g. dispatching an action when the store has a specific field). Calling <code>dispatch()</code> without any conditions is technically possible, however it leads to an infinite loop as every <code>dispatch()</code> call usually triggers the listener again.</p>\n</li><li><p>The subscriptions are snapshotted just before every <code>dispatch()</code> call. If you subscribe or unsubscribe while the listeners are being invoked, this will not have any effect on the <code>dispatch()</code> that is currently in progress. However, the next <code>dispatch()</code> call, whether nested or not, will use a more recent snapshot of the subscription list.</p>\n</li><li><p>The listener should not expect to see all state changes, as the state might have been updated multiple times during a nested <code>dispatch()</code> before the listener is called. It is, however, guaranteed that all subscribers registered before the <code>dispatch()</code> started will be called with the latest state by the time it exits.</p>\n</li></ol><p>It is a low-level API. Most likely, instead of using it directly, you&apos;ll use React (or other) bindings. If you commonly use the callback as a hook to react to state changes, you might want to write a custom <code>observeStore</code> utility. The <code>Store</code> is also an <code>Observable</code>, so you can <code>subscribe</code> to changes with libraries like RxJS. </p><p>To unsubscribe the change listener, invoke the function returned by <code>subscribe</code>.</p><span class="prog__sub">Arguments</span><ol><li><code>listener</code> (<em>Function</em>): The callback to be invoked any time an action has been dispatched, and the state tree might have changed. You may call <code>getState()</code> inside this callback to read the current state tree. It is reasonable to expect that the store&apos;s reducer is a pure function, so you may compare references to some deep path in the state tree to learn whether its value has changed.</li></ol><p>(<em>Function</em>): A function that unsubscribes the change listener.</p><pre><pre><code>function select(state) {\n  return state.some.deep.property\n}\n\nlet currentValue\nfunction handleChange() {\n  let previousValue = currentValue\n  currentValue = select(store.getState())\n\n  if (previousValue !== currentValue) {\n    console.log('Some deep nested property changed from', previousValue, 'to', currentValue)\n  }\n}\n\nlet unsubscribe = store.subscribe(handleChange)\nunsubscribe()\n</code></pre></pre><h3><code>replaceReducer(nextReducer)</code></h3></section>	http://redux.js.org/docs/api/Store.htmlundefined
replaceReducer	A			Redux Store Functions						https://raw.githubusercontent.com/reactjs/redux/master/logo/logo.png	<section class="prog__container"><pre><code>replaceReducer(nextReducer)</code></pre><h3><code>replaceReducer(nextReducer)</code></h3><p>Replaces the reducer currently used by the store to calculate the state.</p><p>It is an advanced API. You might need this if your app implements code splitting, and you want to load some of the reducers dynamically. You might also need this if you implement a hot reloading mechanism for Redux.</p><span class="prog__sub">Arguments</span><ol><li><code>reducer</code> (<em>Function</em>) The next reducer for the store to use.</li></ol></section>	http://redux.js.org/docs/api/Store.htmlundefined
